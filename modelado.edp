// =====================
// Parametros geometricos
// =====================
real W = 3.0;
real H = 2.0;
real gap = 0.3;

real x0 = gap;
real x1 = W - gap;
real y0 = gap;
real y1 = H - gap;

// Definición de las dos aperturas en el costado izquierdo
real lenSpecial = H / 5.0;
real centerSpecial1 = 0.65 * H;
real centerSpecial2 = 0.35 * H;

real yStart1 = centerSpecial1 - lenSpecial / 2.0;
real yEnd1   = centerSpecial1 + lenSpecial / 2.0;

real yStart2 = centerSpecial2 - lenSpecial / 2.0;
real yEnd2   = centerSpecial2 + lenSpecial / 2.0;

// =====================
// Bordes exterior (tubería)
// =====================
border Obottom(t=0,1){ x = t*W; y = 0; label = 2; }
border Oright(t=0,1) { x = W; y = t*H; label = 3; }
border Otop(t=0,1)   { x = W - t*W; y = H; label = 4; }

// Lado izquierdo con dos aperturas
border OleftTop(t=0,1)     { x = 0; y = H - t*(H - yEnd1); label = 3; }
border OleftInlet1(t=0,1)  { x = 0; y = yEnd1 - t*(yEnd1 - yStart1); label = 10; } // entrada 1
border OleftMid(t=0,1)     { x = 0; y = yStart1 - t*(yStart1 - yEnd2); label = 3; }
border OleftInlet2(t=0,1)  { x = 0; y = yEnd2 - t*(yEnd2 - yStart2); label = 11; } // entrada 2
border OleftBottom(t=0,1)  { x = 0; y = yStart2 - t*(yStart2 - 0); label = 3; }

// =====================
// Bordes interior (tablero)
// =====================
border Ibottom(t=0,1){ x = x0 + t*(x1 - x0); y = y0; label = 1; }
border Iright(t=0,1) { x = x1; y = y0 + t*(y1 - y0); label = 1; }
border Itop(t=0,1)   { x = x1 - t*(x1 - x0); y = y1; label = 1; }
border Ileft(t=0,1)  { x = x0; y = y1 - t*(y1 - y0); label = 1; }

// =====================
// Mallas
// =====================
int nSegPerEdgeInner = 60;
mesh meshInner = buildmesh(Ibottom(nSegPerEdgeInner) + Iright(nSegPerEdgeInner)
                          + Itop(nSegPerEdgeInner) + Ileft(nSegPerEdgeInner));

int nSegBottom = 120;
int nSegRight  = 60;
int nSegTop    = 120;
int nSegLeftTop = 20;
int nSegLeftInlet1 = 20;
int nSegLeftMid = 20;
int nSegLeftInlet2 = 20;
int nSegLeftBottom = 20;

mesh meshFrame = buildmesh(
      Obottom(nSegBottom) + Oright(nSegRight) + Otop(nSegTop)
    + OleftTop(nSegLeftTop)
    + OleftInlet1(nSegLeftInlet1)
    + OleftMid(nSegLeftMid)
    + OleftInlet2(nSegLeftInlet2)
    + OleftBottom(nSegLeftBottom)
    + Ibottom(-nSegPerEdgeInner) + Iright(-nSegPerEdgeInner)
    + Itop(-nSegPerEdgeInner) + Ileft(-nSegPerEdgeInner)
);

mesh meshCombined = meshFrame + meshInner;

// =====================
// Espacios finitos
// =====================
fespace Vh(meshFrame, P2); // velocidad
fespace Qh(meshFrame, P1); // presion

fespace ThFrame(meshFrame, P1);   // temperatura exterior
fespace ThInner(meshInner, P1);   // temperatura interior
fespace ThCombined(meshCombined, P1); // visualizacion combinada

// =====================
// Variables
// =====================
// Fluido
Vh u1, u2, v1, v2;
Qh p, q;
Vh u1old, u2old;

// Temperaturas
ThFrame Tf, TfOld, phi;
ThInner Ti, TiOld, psi;

// Visualizacion combinada
ThCombined Tcombined, TfOnCombined, TiOnCombined;

// =====================
// Parametros fisicos y numericos
// =====================
real dt = 0.01;
int nSteps = 200;

real Re = 100.0;
int nPicard = 5;
real picardRelax = 1.0;

// Condiciones de entrada
real Uin = 1.0;   // velocidad horizontal en apertura
real Tin = 1.0;   // temperatura en apertura

// =====================
// Inicializaciones
// =====================
u1old = 0.0; u2old = 0.0;
TfOld = 0.0;
TiOld = 3.0;

// Interpolacion a malla combinada
matrix Tframe2combined = interpolate(ThCombined, ThFrame);
matrix Tinner2combined = interpolate(ThCombined, ThInner);

// Mascaras geometricas
func chiInner = ((x > x0) && (x < x1) && (y > y0) && (y < y1)) ? 1.0 : 0.0;
func chiFrame = 1.0 - chiInner;

// =====================
// Bucle temporal
// =====================
for (int it = 0; it < nSteps; it++) {

    // Navier Stokes evolutivo con Picard (convectivo linealizado)
    for (int k = 0; k < nPicard; k++) {
        problem NS([u1,u2,p],[v1,v2,q]) =
            // masa transitoria
            int2d(meshFrame)( (1.0/dt)*(u1*v1 + u2*v2) )
          - int2d(meshFrame)( (1.0/dt)*(u1old*v1 + u2old*v2) )

            // difusion (viscosidad) 1/Re
          + int2d(meshFrame)(
                (dx(u1)*dx(v1) + dy(u1)*dy(v1)
               + dx(u2)*dx(v2) + dy(u2)*dy(v2)) / Re
            )

            // convectivo linealizado con campo anterior
          + int2d(meshFrame)(
                (u1old*dx(u1) + u2old*dy(u1)) * v1
              + (u1old*dx(u2) + u2old*dy(u2)) * v2
            )

            // acoplamiento presion-velocidad e incomprensibilidad
          - int2d(meshFrame)( p*(dx(v1) + dy(v2)) )
          - int2d(meshFrame)( q*(dx(u1) + dy(u2)) )

            // condiciones de frontera
          + on(10, u1 = Uin, u2 = 0.0)   // entrada 1
          + on(11, u1 = Uin, u2 = 0.0)   // entrada 2
          + on(2,3,4,1, u1 = 0.0, u2 = 0.0)  // paredes
          + on(4, p = 0.0);               // referencia presion

        NS;

        // actualizacion Picard
        u1old = (1.0 - picardRelax)*u1old + picardRelax*u1;
        u2old = (1.0 - picardRelax)*u2old + picardRelax*u2;
    }

    // Temperatura exterior: adveccion-difusion implicita
    problem HeatFrame(Tf, phi) =
        int2d(meshFrame)( (1.0/dt) * Tf * phi )
      + int2d(meshFrame)( dx(Tf)*dx(phi) + dy(Tf)*dy(phi) )
      + int2d(meshFrame)( (u1*dx(Tf) + u2*dy(Tf)) * phi )
      - int2d(meshFrame)( (1.0/dt) * TfOld * phi )
      + on(10, Tf = Tin) + on(11, Tf = Tin);
    HeatFrame;
    TfOld = Tf;

    // Temperatura interior: calor con Dirichlet = Tf en la frontera compartida
    func DirichletInner = Tf;
    problem HeatInner(Ti, psi) =
        int2d(meshInner)( (1.0/dt) * Ti * psi )
      + int2d(meshInner)( 0.5*(dx(Ti)*dx(psi) + dy(Ti)*dy(psi)))
      - int2d(meshInner)( (1.0/dt) * TiOld * psi )
      + on(1, Ti = DirichletInner);
    HeatInner;
    TiOld = Ti;

    // Interpolar y combinar para visualizacion
    TfOnCombined[] = Tframe2combined * Tf[];
    TiOnCombined[] = Tinner2combined * Ti[];
    Tcombined = chiFrame * TfOnCombined + chiInner * TiOnCombined;

    // Visualizacion
    plot(meshCombined, Tcombined, value = true, fill = true,
         cmm = "t = " + it, wait = false);
}

// =====================
// Plots finales
// =====================
plot(meshFrame, u1, u2, wait = true,
     cmm = "velocidad exterior final vector");

plot(meshInner, Ti, value = true, fill = true, wait = true,
     cmm = "temperatura interior final");